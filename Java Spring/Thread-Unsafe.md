
# Race Condition

想象一下，只剩 **1 个** 苹果时，**线程 A** 和 **线程 B** 同时进来了：

1. **时间点 0.01ms:** 线程 A 问数据库：“还有多少？” 数据库说：“还有 **1** 个”。
    
2. **时间点 0.01ms:** 线程 B 问数据库：“还有多少？” 数据库说：“还有 **1** 个”（注意：A 还没来得及减）。
    
3. **时间点 0.02ms:** 线程 A 很高兴：“太好了，买它！” 于是计算 `1 - 1 = 0`。
    
4. **时间点 0.03ms:** 线程 B 也很高兴：“太好了，买它！” 于是计算 `1 - 1 = 0`。
    
5. **时间点 0.04ms:** 线程 A 把 **0** 写回数据库。
    
6. **时间点 0.05ms:** 线程 B 把 **0** 写回数据库。
    

**结果：** 两个人都觉得买了苹果，都发了货，但库存只减了 1 次。 **放大来看：** 你那 1000 个线程里，有几百次这样的“同时读取、互相覆盖”，导致明明卖了几百个苹果，库存却只像蜗牛一样慢慢减了 80 个。


![[Pasted image 20260203013100.png]]

![[Pasted image 20260203013142.png]]

![[Pasted image 20260203012748.png]]

![[Pasted image 20260203012726.png]]



# Synchronized
Mutual Exclusion Lock 互斥锁: This piece of code only can have one thread go in at a time.

![[Pasted image 20260203013034.png]]

![[Pasted image 20260203013155.png]]