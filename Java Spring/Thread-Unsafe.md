
# Race Condition
**本质逻辑是：非原子性操作 (Non-atomic Operation)。** 你的 `buy` 方法包含了：**1. 读 -> 2. 改 -> 3. 写**。 只要这三步不是一气呵成的（中间可以被别人插足），它就是 Thread-Unsafe 的。

想象一下，只剩 **1 个** 苹果时，**线程 A** 和 **线程 B** 同时进来了：

1. **时间点 0.01ms:** 线程 A 问数据库：“还有多少？” 数据库说：“还有 **1** 个”。
    
2. **时间点 0.01ms:** 线程 B 问数据库：“还有多少？” 数据库说：“还有 **1** 个”（注意：A 还没来得及减）。
    
3. **时间点 0.02ms:** 线程 A 很高兴：“太好了，买它！” 于是计算 `1 - 1 = 0`。
    
4. **时间点 0.03ms:** 线程 B 也很高兴：“太好了，买它！” 于是计算 `1 - 1 = 0`。
    
5. **时间点 0.04ms:** 线程 A 把 **0** 写回数据库。
    
6. **时间点 0.05ms:** 线程 B 把 **0** 写回数据库。
    

**结果：** 两个人都觉得买了苹果，都发了货，但库存只减了 1 次。 **放大来看：** 你那 1000 个线程里，有几百次这样的“同时读取、互相覆盖”，导致明明卖了几百个苹果，库存却只像蜗牛一样慢慢减了 80 个。


![[Pasted image 20260203013100.png]]

![[Pasted image 20260203013142.png]]

![[Pasted image 20260203012748.png]]

![[Pasted image 20260203012726.png]]



## Synchronized
Mutual Exclusion Lock 互斥锁: This piece of code only can have one thread go in at a time.

![[Pasted image 20260203013034.png]]

![[Pasted image 20260203013155.png]]

💡
“有没有更高效的方法？不要让大家傻排队，但又要保证安全？”

### 悲观锁 (Pessimistic Lock)
霸道总裁模式，我查的时候别人连看都不能看。

### 乐观锁 (Optimistic Lock)
佛系模式，大家随便看，但提交时如果发现别人改过了，我就报错重来。

# Visibility
- **现象：** 线程 A 修改了一个全局变量，线程 B 却看不见，依然在用旧的值。
    
- **Why：** 现代 CPU 有 L1/L2 缓存。线程 A 可能只改了自己的 CPU 缓存，没写回主内存（Main Memory）。
    
- **解决方法：** 使用 `volatile` 关键字（你之前问过的那个词！）。

# Instruction Reordering
- 为了优化性能，编译器或 CPU 会自作聪明地乱改你的代码顺序。
    
- **例子：** 你写的是 `a = 1; b = 2;`，CPU 觉得先执行 `b = 2` 更快。在单线程没问题，但在多线程下，如果线程 B 依赖 `a` 的值来判断 `b` 是否可用，就会瞬间崩掉。
    
- **解决方法：** 还是 `volatile`（它能建立内存屏障，禁止乱排）。

# Deadlock
- **现象：** 线程 A 拿着锁 1 想要锁 2，线程 B 拿着锁 2 想要锁 1。大家都不松手，系统直接卡死。
    
- **Why：** 锁的申请顺序不一致导致的逻辑闭环。